{"version":3,"file":"ol-elevation-parser.min.js","sources":["../node_modules/array-smooth/lib/index.js","../src/helpers.ts","../src/logger.ts","../src/defaults.ts","../src/readFromImage.ts","../src/ol-elevation-parser.ts","../src/index-umd.ts"],"sourcesContent":["function smooth(arr, windowSize, getter = (value) => value, setter) {\n  const get = getter\n  const result = []\n\n  for (let i = 0; i < arr.length; i += 1) {\n    const leftOffeset = i - windowSize\n    const from = leftOffeset >= 0 ? leftOffeset : 0\n    const to = i + windowSize + 1\n\n    let count = 0\n    let sum = 0\n    for (let j = from; j < to && j < arr.length; j += 1) {\n      sum += get(arr[j])\n      count += 1\n    }\n\n    result[i] = setter ? setter(arr[i], sum / count) : sum / count\n  }\n\n  return result\n}\n\nmodule.exports = smooth\n","// @turf\r\nimport bbox from '@turf/bbox';\r\nimport area from '@turf/area';\r\nimport intersect from '@turf/intersect';\r\nimport { featureCollection } from '@turf/helpers';\r\nimport squareGrid from '@turf/square-grid';\r\n\r\nimport smooth from 'array-smooth';\r\n\r\nimport Polygon from 'ol/geom/Polygon.js';\r\nimport LineString from 'ol/geom/LineString.js';\r\nimport Feature from 'ol/Feature.js';\r\nimport GeoJSON from 'ol/format/GeoJSON.js';\r\nimport { CoordinatesXY, CoordinatesXYZ, Options } from './ol-elevation-parser';\r\n\r\nconst geojson = new GeoJSON();\r\n\r\n/**\r\n *\r\n * @param target\r\n * @param sources\r\n * @returns\r\n */\r\nexport const deepObjectAssign = (target, ...sources) => {\r\n    sources.forEach((source) => {\r\n        Object.keys(source).forEach((key) => {\r\n            const s_val = source[key];\r\n            const t_val = target[key];\r\n            target[key] =\r\n                t_val &&\r\n                s_val &&\r\n                typeof t_val === 'object' &&\r\n                typeof s_val === 'object' &&\r\n                !Array.isArray(t_val) // Don't merge arrays\r\n                    ? deepObjectAssign(t_val, s_val)\r\n                    : s_val;\r\n        });\r\n    });\r\n    return target;\r\n};\r\n\r\nexport const getLineSamples = (\r\n    geom: LineString,\r\n    nSamples: Options['samples']\r\n): CoordinatesXY[] => {\r\n    const totalLength = geom.getLength();\r\n\r\n    if (typeof nSamples === 'function') {\r\n        nSamples = nSamples(totalLength);\r\n    }\r\n\r\n    const stepPercentage = 100 / nSamples;\r\n\r\n    const metersSample = totalLength * (stepPercentage / 100);\r\n\r\n    const sampledCoords: CoordinatesXY[] = [];\r\n    let segmentCount = 0;\r\n\r\n    // Get samples every percentage step while conserving all the vertex\r\n    geom.forEachSegment(\r\n        (\r\n            start: CoordinatesXY | CoordinatesXYZ,\r\n            end: CoordinatesXY | CoordinatesXYZ\r\n        ) => {\r\n            // Only get the first start segment\r\n            if (!segmentCount) {\r\n                sampledCoords.push([start[0], start[1]] as CoordinatesXY);\r\n            }\r\n\r\n            segmentCount++;\r\n\r\n            const segmentGeom = new LineString([\r\n                [start[0], start[1]],\r\n                [end[0], end[1]]\r\n            ]);\r\n            const segmentLength = segmentGeom.getLength();\r\n\r\n            /**\r\n             * segmentLength -> 100\r\n             * metersSample -> x\r\n             */\r\n            const newPercentage = (100 * metersSample) / segmentLength;\r\n\r\n            // skip 0 and 100\r\n            let segmentStepPercent = newPercentage;\r\n            while (segmentStepPercent < 100) {\r\n                const coordAt = segmentGeom.getCoordinateAt(\r\n                    segmentStepPercent / 100\r\n                ) as CoordinatesXY;\r\n                sampledCoords.push(coordAt);\r\n                segmentStepPercent = segmentStepPercent + newPercentage;\r\n            }\r\n\r\n            sampledCoords.push([end[0], end[1]]);\r\n        }\r\n    );\r\n\r\n    return sampledCoords;\r\n};\r\n\r\n/**\r\n * @param polygonFeature\r\n * @param nSamples\r\n * @returns\r\n */\r\nexport const getPolygonSamples = (\r\n    polygonFeature: Feature<Polygon>,\r\n    projection: string,\r\n    nSamples: Options['sampleSizeArea']\r\n): Feature<Polygon>[] => {\r\n    const polygon = geojson.writeFeatureObject(polygonFeature, {\r\n        dataProjection: 'EPSG:4326',\r\n        featureProjection: projection\r\n    }) as any;\r\n\r\n    const areaPol = area(polygon.geometry);\r\n\r\n    let sampleMeters: number;\r\n\r\n    if (nSamples !== 'auto') {\r\n        if (typeof nSamples === 'number') {\r\n            sampleMeters = nSamples;\r\n        } else if (typeof nSamples === 'function') {\r\n            sampleMeters = nSamples(areaPol);\r\n        }\r\n    } else {\r\n        if (areaPol <= 1000) sampleMeters = 0.5;\r\n        else if (areaPol < 10000) sampleMeters = 1;\r\n        else if (areaPol < 100000) sampleMeters = 10;\r\n        else if (areaPol < 1000000) sampleMeters = 50;\r\n        else sampleMeters = 100;\r\n    }\r\n\r\n    const polygonBbox = bbox(polygon);\r\n\r\n    const grid = squareGrid(polygonBbox, sampleMeters / 1000, {\r\n        units: 'kilometers',\r\n        mask: polygon.geometry\r\n    });\r\n\r\n    let clippedGrid = grid.features.map((feature) =>\r\n        intersect(feature.geometry, polygon)\r\n    );\r\n\r\n    // Remove some random null values\r\n    clippedGrid = clippedGrid.filter((feature) => feature);\r\n\r\n    const clippedGridF = featureCollection(clippedGrid);\r\n\r\n    return geojson.readFeatures(clippedGridF, {\r\n        dataProjection: 'EPSG:4326',\r\n        featureProjection: projection\r\n    }) as Feature<Polygon>[];\r\n};\r\n\r\n/**\r\n *\r\n * @param coordsWithZ\r\n * @param smoothValue\r\n * @returns\r\n */\r\nexport const getSmoothedCoords = (\r\n    coordsWithZ: CoordinatesXYZ[],\r\n    smoothValue = 0\r\n): CoordinatesXYZ[] => {\r\n    coordsWithZ = [...coordsWithZ];\r\n    const zCoords = coordsWithZ.map((coord) => coord[2]);\r\n\r\n    const zSmooth = smooth(zCoords, smoothValue) as number[];\r\n\r\n    return coordsWithZ.map((coord, i) => {\r\n        coord[2] = zSmooth[i];\r\n        return coord;\r\n    });\r\n};\r\n\r\n/**\r\n *\r\n * @param src\r\n * @returns\r\n */\r\nexport const addSrcToImage = (\r\n    img: HTMLImageElement,\r\n    src: string\r\n): Promise<any> => {\r\n    return new Promise((resolve, reject) => {\r\n        img.onload = () => resolve(img.height);\r\n        img.onerror = reject;\r\n        img.src = src;\r\n    });\r\n};\r\n","export let loggerIsEnabled = false;\r\n\r\nexport const setLoggerActive = (bool: boolean) => {\r\n    loggerIsEnabled = bool;\r\n};\r\n\r\nexport default function logger(...args) {\r\n    if (loggerIsEnabled) console.log(...args);\r\n}\r\n","import { Options } from './ol-elevation-parser';\r\nimport { loggerIsEnabled } from './logger';\r\n\r\nconst options: Options = {\r\n    source: null,\r\n    calculateZMethod: 'getFeatureInfo',\r\n    tilesResolution: 'current',\r\n    bands: 4,\r\n    samples: 50,\r\n    smooth: 0,\r\n    sampleSizeArea: 'auto',\r\n    noDataValue: -10000,\r\n    timeout: 5000,\r\n    verbose: loggerIsEnabled\r\n};\r\n\r\nexport default options;\r\n","import Map from 'ol/Map.js';\r\nimport View from 'ol/View.js';\r\nimport { Coordinate } from 'ol/coordinate.js';\r\nimport {\r\n    getForProjection as getTileGridForProjection,\r\n    createXYZ\r\n} from 'ol/tilegrid.js';\r\nimport TileGrid from 'ol/tilegrid/TileGrid.js';\r\nimport XYZ from 'ol/source/XYZ.js';\r\nimport DataTile, { Data } from 'ol/DataTile.js';\r\nimport ImageTile from 'ol/ImageTile.js';\r\nimport Projection from 'ol/proj/Projection.js';\r\n\r\nimport { Options, RasterSources } from './ol-elevation-parser.js';\r\n\r\nconst mapboxExtractElevation = (r: number, g: number, b: number): number => {\r\n    return (r * 256 * 256 + g * 256 + b) * 0.1 - 10000;\r\n};\r\n\r\nconst terrariumExtractElevation = (r: number, g: number, b: number): number => {\r\n    return r * 256 + g + b / 256 - 32768;\r\n};\r\n\r\nexport default class ReadFromImage {\r\n    protected _projection: Projection;\r\n    protected _source: RasterSources;\r\n    protected _view: View;\r\n    protected _calculateZMethod: Options['calculateZMethod'];\r\n    protected _bands: Options['bands'];\r\n    protected _canvas: HTMLCanvasElement;\r\n    protected _ctx: CanvasRenderingContext2D;\r\n\r\n    constructor(\r\n        source: RasterSources,\r\n        calculateZMethod: Options['calculateZMethod'],\r\n        bands: Options['bands'],\r\n        map: Map\r\n    ) {\r\n        this._projection =\r\n            source.getProjection() || map.getView().getProjection();\r\n        this._view = map.getView();\r\n\r\n        this._source = source;\r\n        this._bands = bands;\r\n\r\n        this._calculateZMethod = calculateZMethod;\r\n\r\n        this._canvas = document.createElement('canvas');\r\n        this._ctx = this._canvas.getContext('2d');\r\n    }\r\n\r\n    async read(coordinate: Coordinate, resolution: number) {\r\n        // clear canvas\r\n        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n\r\n        const tileGrid = this._getTileGrid();\r\n\r\n        const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\r\n            coordinate,\r\n            resolution\r\n        );\r\n        const zoom = tileCoord[0];\r\n        const tileSize = tileGrid.getTileSize(zoom);\r\n\r\n        const tile = this._source.getTile(\r\n            tileCoord[0],\r\n            tileCoord[1],\r\n            tileCoord[2],\r\n            1,\r\n            this._projection\r\n        );\r\n\r\n        if (tile.getState() !== 2) {\r\n            await new Promise((resolve) => {\r\n                const changeListener = () => {\r\n                    if (tile.getState() === 2) {\r\n                        // loaded\r\n                        tile.removeEventListener('change', changeListener);\r\n                        resolve(null);\r\n                    } else if (tile.getState() === 3) {\r\n                        // error\r\n                        resolve(null);\r\n                    }\r\n                };\r\n\r\n                tile.addEventListener('change', changeListener);\r\n                tile.load();\r\n            });\r\n        }\r\n\r\n        let tileData: Data | HTMLImageElement;\r\n\r\n        if (tile instanceof DataTile) {\r\n            tileData = tile.getData();\r\n        } else if (tile instanceof ImageTile) {\r\n            tileData = tile.getImage();\r\n        }\r\n\r\n        if (!tileData) return;\r\n\r\n        //@ts-ignore\r\n        // sometimes tilesize is wrong, so use tileData if exists\r\n        const width = tileData.width || tileSize[0] || tileSize;\r\n\r\n        //@ts-ignore\r\n        const height = tileData.height || tileSize[1] || tileSize;\r\n\r\n        this._canvas.width = width;\r\n        this._canvas.height = height;\r\n\r\n        //@ts-expect-error\r\n        this._ctx.mozImageSmoothingEnabled = false;\r\n        //@ts-expect-error\r\n        this._ctx.oImageSmoothingEnabled = false;\r\n        //@ts-expect-error\r\n        this._ctx.webkitImageSmoothingEnabled = false;\r\n        //@ts-expect-error\r\n        this._ctx.msImageSmoothingEnabled = false;\r\n        this._ctx.imageSmoothingEnabled = false;\r\n\r\n        let imageData: ImageData;\r\n\r\n        if (tileData instanceof HTMLImageElement) {\r\n            // Add image to a canvas\r\n            this._ctx.drawImage(tileData, 0, 0);\r\n\r\n            imageData = this._ctx.getImageData(0, 0, width, height);\r\n        } else {\r\n            // GeoTIFF\r\n            imageData = this._ctx.createImageData(width, height);\r\n            //@ts-expect-error\r\n            imageData.data.set(tileData as Data);\r\n        }\r\n\r\n        const origin = tileGrid.getOrigin(zoom);\r\n        const res = tileGrid.getResolution(zoom);\r\n\r\n        const w = Math.floor(((coordinate[0] - origin[0]) / res) % width);\r\n        const h = Math.floor(((origin[1] - coordinate[1]) / res) % height);\r\n\r\n        const imgData = imageData.data;\r\n        const index = (w + h * width) * this._bands;\r\n\r\n        const pixel = [\r\n            imgData[index + 0],\r\n            imgData[index + 1],\r\n            imgData[index + 2],\r\n            imgData[index + 3]\r\n        ];\r\n\r\n        return this._extractValuesFromPixelDEM(pixel);\r\n    }\r\n\r\n    /**\r\n     * Get the Max Resolution of the source\r\n     * @returns\r\n     */\r\n    getMaxResolution(): number {\r\n        const zoom = this._getTileGrid().getMaxZoom();\r\n        if (zoom) return this._getTileGrid().getResolution(zoom);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if this is now necesary\r\n     * @returns\r\n     */\r\n    private _getTileGrid(): TileGrid {\r\n        let tilegrid = this._source.getTileGrid();\r\n        // If not tileGrid is provided, set a default for XYZ sources\r\n        if (!tilegrid) {\r\n            if (this._source instanceof XYZ) {\r\n                const defaultTileGrid = createXYZ();\r\n                tilegrid = new TileGrid({\r\n                    origin: defaultTileGrid.getOrigin(0),\r\n                    resolutions: defaultTileGrid.getResolutions()\r\n                });\r\n            } else {\r\n                tilegrid = getTileGridForProjection(this._projection);\r\n            }\r\n        }\r\n\r\n        return tilegrid;\r\n    }\r\n\r\n    /**\r\n     * @param pixel\r\n     * @returns\r\n     */\r\n    private _extractValuesFromPixelDEM(pixel: number[]): number {\r\n        if (\r\n            this._calculateZMethod &&\r\n            typeof this._calculateZMethod === 'function'\r\n        ) {\r\n            return this._calculateZMethod(pixel[0], pixel[1], pixel[2]);\r\n        } else if (this._calculateZMethod === 'Mapbox') {\r\n            return mapboxExtractElevation(pixel[0], pixel[1], pixel[2]);\r\n        } else if (this._calculateZMethod === 'Terrarium') {\r\n            return terrariumExtractElevation(pixel[0], pixel[1], pixel[2]);\r\n        }\r\n    }\r\n}\r\n","import LineString from 'ol/geom/LineString.js';\r\nimport Point from 'ol/geom/Point.js';\r\nimport Polygon from 'ol/geom/Polygon.js';\r\nimport Control, { Options as ControlOptions } from 'ol/control/Control.js';\r\nimport TileImage from 'ol/source/TileImage.js';\r\nimport TileWMS from 'ol/source/TileWMS.js';\r\nimport XYZ from 'ol/source/XYZ.js';\r\nimport GeoTIFF from 'ol/source/GeoTIFF';\r\nimport View from 'ol/View.js';\r\nimport { Coordinate } from 'ol/coordinate.js';\r\nimport Feature from 'ol/Feature.js';\r\nimport Map from 'ol/Map.js';\r\nimport { EventsKey } from 'ol/events.js';\r\nimport BaseEvent from 'ol/events/Event.js';\r\nimport { CombinedOnSignature, EventTypes, OnSignature } from 'ol/Observable.js';\r\nimport { ObjectEvent } from 'ol/Object.js';\r\nimport { Types as ObjectEventTypes } from 'ol/ObjectEventType.js';\r\n\r\nimport {\r\n    deepObjectAssign,\r\n    getLineSamples,\r\n    getPolygonSamples,\r\n    getSmoothedCoords\r\n} from './helpers';\r\nimport defaultOptions from './defaults';\r\nimport logger, { setLoggerActive } from './logger';\r\nimport ReadFromImage from './readFromImage';\r\n\r\n/**\r\n * @extends {ol/control/Control~Control}\r\n * @fires change:samples\r\n * @fires change:sampleSizeArea\r\n * @fires change:source\r\n * @fires change:calculateZMethod\r\n * @fires change:noDataValue\r\n * @fires change:smooth\r\n * @fires change:tilesResolution\r\n * @fires change:bands\r\n * @param options\r\n */\r\nexport default class ElevationParser extends Control {\r\n    protected _options: Options;\r\n    protected _countConnections = 0;\r\n    protected _readFromImage: ReadFromImage;\r\n    protected _rasterSourceIsLoaded = false;\r\n\r\n    protected _initialized = false;\r\n\r\n    declare on: OnSignature<\r\n        EventTypes | `${GeneralEventTypes}`,\r\n        BaseEvent,\r\n        EventsKey\r\n    > &\r\n        OnSignature<\r\n            ObjectEventTypes | ElevationParserEventTypes,\r\n            ObjectEvent,\r\n            EventsKey\r\n        > &\r\n        CombinedOnSignature<\r\n            ElevationParserEventTypes | ObjectEventTypes | EventTypes,\r\n            EventsKey\r\n        >;\r\n\r\n    declare once: OnSignature<\r\n        EventTypes | `${GeneralEventTypes}`,\r\n        BaseEvent,\r\n        EventsKey\r\n    > &\r\n        OnSignature<\r\n            ObjectEventTypes | ElevationParserEventTypes,\r\n            ObjectEvent,\r\n            EventsKey\r\n        > &\r\n        CombinedOnSignature<\r\n            ElevationParserEventTypes | ObjectEventTypes | EventTypes,\r\n            EventsKey\r\n        >;\r\n\r\n    declare un: OnSignature<EventTypes, BaseEvent, void> &\r\n        OnSignature<\r\n            ObjectEventTypes | ElevationParserEventTypes,\r\n            ObjectEvent,\r\n            void\r\n        > &\r\n        CombinedOnSignature<\r\n            | ElevationParserEventTypes\r\n            | ObjectEventTypes\r\n            | EventTypes\r\n            | `${GeneralEventTypes}`,\r\n            void\r\n        >;\r\n\r\n    constructor(options: Options) {\r\n        super({\r\n            element: document.createElement('div')\r\n        });\r\n\r\n        this._options = deepObjectAssign({}, defaultOptions, options);\r\n\r\n        // Change the default 'getFeatureInfo' method if the source is not TileWMS\r\n        if (\r\n            !(this._options.source instanceof TileWMS) &&\r\n            this._options.calculateZMethod === 'getFeatureInfo'\r\n        ) {\r\n            this._options.calculateZMethod = 'Mapbox';\r\n        }\r\n\r\n        setLoggerActive(this._options.verbose);\r\n    }\r\n\r\n    /**\r\n     * Get Feature's elevation values.\r\n     * Use custom options to overwrite the general ones for specific cases\r\n     *\r\n     * @param feature\r\n     * @param customOptions\r\n     * @returns\r\n     * @public\r\n     */\r\n    async getElevationValues(\r\n        feature: Feature<LineString | Point | Polygon>,\r\n        customOptions: ElevationValuesIndividualOptions = null\r\n    ): Promise<IGetElevationValues | Error> {\r\n        try {\r\n            const waitUntilRasterSourceIsLoaded = () =>\r\n                new Promise((resolve, reject) => {\r\n                    const isSourceReady = (\r\n                        retryNum = 0,\r\n                        maxRetries = 5,\r\n                        waitMilliseconds = 500\r\n                    ) => {\r\n                        if ((source as RasterSources).getState() !== 'ready') {\r\n                            retryNum++;\r\n\r\n                            if (retryNum > maxRetries) {\r\n                                reject();\r\n                            } else {\r\n                                setTimeout(\r\n                                    () => isSourceReady(retryNum++),\r\n                                    waitMilliseconds\r\n                                );\r\n                            }\r\n                        } else {\r\n                            resolve(null);\r\n                        }\r\n                    };\r\n\r\n                    isSourceReady();\r\n                });\r\n\r\n            const { sampledCoords, gridPolygons } = this._sampleFeatureCoords(\r\n                feature,\r\n                customOptions\r\n            );\r\n\r\n            let contourCoords: CoordinatesXYZ[], mainCoords: CoordinatesXYZ[];\r\n\r\n            const source = this.get('source') as Options['source'];\r\n\r\n            if (typeof source === 'function') {\r\n                // Use a custom function. Useful for using apis to retrieve the zvalues\r\n                ({ mainCoords, contourCoords } = await source(\r\n                    feature,\r\n                    sampledCoords\r\n                ));\r\n            } else {\r\n                if (!this._rasterSourceIsLoaded) {\r\n                    await waitUntilRasterSourceIsLoaded();\r\n                    this._rasterSourceIsLoaded = true;\r\n                }\r\n\r\n                mainCoords = await this._getZFromSampledCoords(\r\n                    sampledCoords.mainCoords,\r\n                    customOptions\r\n                );\r\n\r\n                // Only Polygons\r\n                if (mainCoords && sampledCoords.contourCoords) {\r\n                    contourCoords = await this._getZFromSampledCoords(\r\n                        sampledCoords.contourCoords,\r\n                        customOptions\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (mainCoords === null) {\r\n                return null;\r\n            }\r\n\r\n            const smooth = customOptions?.smooth || this.get('smooth');\r\n\r\n            if (smooth) {\r\n                mainCoords = getSmoothedCoords(mainCoords, smooth);\r\n            }\r\n\r\n            return {\r\n                mainCoords,\r\n                ...(contourCoords && {\r\n                    contourCoords\r\n                }),\r\n                ...(gridPolygons && {\r\n                    gridPolygons\r\n                })\r\n            };\r\n        } catch (err) {\r\n            this.dispatchEvent('error');\r\n            return err;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getSource(): Options['source'] {\r\n        return this.get('source');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param source\r\n     */\r\n    setSource(source: Options['source'], silent = false): void {\r\n        this.set('source', source, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getSamples(): Options['samples'] {\r\n        return this.get('samples');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param samples\r\n     */\r\n    setSamples(samples: Options['samples'], silent = false): void {\r\n        this.set('samples', samples, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getSampleSizeArea(): Options['sampleSizeArea'] {\r\n        return this.get('sampleSizeArea');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param sampleSizeArea\r\n     */\r\n    setSampleSizeArea(\r\n        sampleSizeArea: Options['sampleSizeArea'],\r\n        silent: boolean\r\n    ): void {\r\n        this.set('sampleSizeArea', sampleSizeArea, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getCalculateZMethod(): Options['calculateZMethod'] {\r\n        return this.get('calculateZMethod');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param calculateZMethod\r\n     */\r\n    setCalculateZMethod(\r\n        calculateZMethod: Options['calculateZMethod'],\r\n        silent = false\r\n    ): void {\r\n        this.set('calculateZMethod', calculateZMethod, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getSmooth(): Options['smooth'] {\r\n        return this.get('smooth');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param smooth\r\n     */\r\n    setSmooth(smooth: Options['smooth'], silent = false): void {\r\n        this.set('smooth', smooth, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getNoDataValue(): Options['noDataValue'] {\r\n        return this.get('noDataValue');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param noDataValue\r\n     */\r\n    setNoDataValue(noDataValue: Options['noDataValue'], silent = false): void {\r\n        this.set('noDataValue', noDataValue, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getTilesResolution(): Options['tilesResolution'] {\r\n        return this.get('tilesResolution');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param tilesResolution\r\n     */\r\n    setTilesResolution(\r\n        tilesResolution: Options['tilesResolution'],\r\n        silent = false\r\n    ): void {\r\n        this.set('tilesResolution', tilesResolution, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getBands(): Options['bands'] {\r\n        return this.get('bands');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param bands\r\n     */\r\n    setBands(bands: Options['bands'], silent = false): void {\r\n        this.set('bands', bands, silent);\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @returns\r\n     */\r\n    getTimeout(): Options['timeout'] {\r\n        return this.get('timeout');\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param timeout\r\n     */\r\n    setTimeout(timeout: Options['timeout'], silent = false): void {\r\n        this.set('timeout', timeout, silent);\r\n    }\r\n\r\n    /**\r\n     * Maximum tile resolution of the image source\r\n     * Only if the source is a raster\r\n     *\r\n     * @public\r\n     * @returns\r\n     */\r\n    getMaxTilesResolution(): number {\r\n        if (this._readFromImage) return this._readFromImage.getMaxResolution();\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Current view resolution\r\n     * Unsupported if the view of a GeoTIFF is used in the map\r\n     *\r\n     * @public\r\n     * @returns\r\n     */\r\n    getCurrentViewResolution(): number {\r\n        return this.getMap().getView().getResolution();\r\n    }\r\n\r\n    /**\r\n     * @public\r\n     * @param map\r\n     * @TODO remove events if map is null\r\n     */\r\n    setMap(map: Map): void {\r\n        super.setMap(map);\r\n\r\n        if (map) {\r\n            // Run once\r\n            if (!this._initialized) this._init();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param coords\r\n     * @param optOptions To overwrite the general ones\r\n     * @returns\r\n     * @private\r\n     */\r\n    private _getZFromSampledCoords = async (\r\n        coords: Coordinate[],\r\n        optOptions: ElevationValuesIndividualOptions = null\r\n    ): Promise<CoordinatesXYZ[]> => {\r\n        const RESOLUTION_NUMBER_FALLBACK = 0.01;\r\n\r\n        this._countConnections++;\r\n        const countConnections = this._countConnections;\r\n        let errorCount = 0;\r\n\r\n        const coordsWithZ = [];\r\n\r\n        const source = this.get('source');\r\n\r\n        // Flexible error trigger if multiples coords must be requested.\r\n        // If only one coord is needed, the error is strict and raised inmediatly\r\n        // This is useful if multipels coords are needed, and maybe one or two return error\r\n        const countErrorsLimit = coords.length >= 5 ? 1 : 5;\r\n\r\n        let resolutionNumber: number;\r\n\r\n        const _resolution =\r\n            optOptions?.tilesResolution || this.getTilesResolution();\r\n\r\n        if (_resolution === 'current') {\r\n            resolutionNumber = this.getMap().getView().getResolution();\r\n            // if the view of a GeoTIFF is used in the map\r\n            if (!resolutionNumber) {\r\n                console.warn('Cannot calculate current view resolution');\r\n            }\r\n        } else if (_resolution === 'max') {\r\n            const maxRes = this.getMaxTilesResolution();\r\n            if (maxRes) resolutionNumber = maxRes;\r\n            else console.warn(\"Cannot calculate source's max resolution\");\r\n        } else {\r\n            // resolution is a explicit number provided in the config\r\n            resolutionNumber = _resolution;\r\n        }\r\n\r\n        if (!resolutionNumber) {\r\n            resolutionNumber =\r\n                this.getMap().getView().getMinResolution() ||\r\n                RESOLUTION_NUMBER_FALLBACK;\r\n            console.warn('Using fallback resolution:', resolutionNumber);\r\n        }\r\n\r\n        for (const coord of coords) {\r\n            try {\r\n                // If there is a new connection (onChange event), abort this\r\n                if (this._countConnections !== countConnections) {\r\n                    logger('New geometry detected, previous requests aborted');\r\n                    return null;\r\n                }\r\n\r\n                let zValue: number;\r\n\r\n                if (\r\n                    source instanceof TileWMS &&\r\n                    this.get('calculateZMethod') === 'getFeatureInfo'\r\n                ) {\r\n                    zValue = await this._getZValuesFromWMS(\r\n                        coord,\r\n                        source,\r\n                        this.getMap().getView()\r\n                    );\r\n                } else {\r\n                    zValue = await this._getZValuesFromImage(\r\n                        coord,\r\n                        resolutionNumber\r\n                    );\r\n                }\r\n\r\n                if (this.get('noDataValue') !== false) {\r\n                    zValue =\r\n                        zValue === this.get('noDataValue') ? undefined : zValue;\r\n                }\r\n\r\n                const baseValue =\r\n                    this.get('calculateZMethod') === 'Terrarium'\r\n                        ? -32768\r\n                        : undefined;\r\n\r\n                const zValueRound =\r\n                    typeof zValue !== 'undefined' && zValue !== baseValue\r\n                        ? Number(zValue.toFixed(3))\r\n                        : undefined;\r\n\r\n                coordsWithZ.push([...coord, zValueRound]);\r\n            } catch (err) {\r\n                errorCount++;\r\n                console.error(err);\r\n                if (errorCount >= countErrorsLimit) {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n\r\n        return coordsWithZ;\r\n    };\r\n\r\n    /**\r\n     * This is trigged once\r\n     * @private\r\n     */\r\n    private _init(): void {\r\n        this.setSamples(this._options.samples, /* silent = */ true);\r\n\r\n        this.setSampleSizeArea(\r\n            this._options.sampleSizeArea,\r\n            /* silent = */ true\r\n        );\r\n\r\n        this.setCalculateZMethod(\r\n            this._options.calculateZMethod,\r\n            /* silent = */ true\r\n        );\r\n\r\n        this.setNoDataValue(this._options.noDataValue, /* silent = */ true);\r\n\r\n        this.setSmooth(this._options.smooth, /* silent = */ true);\r\n\r\n        this.setTilesResolution(\r\n            this._options.tilesResolution,\r\n            /* silent = */ true\r\n        );\r\n\r\n        this.setBands(this._options.bands, /* silent = */ true);\r\n\r\n        this.setTimeout(this._options.timeout, /* silent = */ true);\r\n\r\n        // Need to be the latest, fires the change event\r\n        this.setSource(this._options.source, /* silent = */ true);\r\n\r\n        this._addPropertyEvents();\r\n\r\n        this._onInitModifySource();\r\n\r\n        this._initialized = true;\r\n\r\n        this.dispatchEvent(GeneralEventTypes.LOAD);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    private _addPropertyEvents(): void {\r\n        this.on(\r\n            ['change:source', 'change:bands', 'change:calculateZMethod'],\r\n            () => {\r\n                this._onInitModifySource();\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Run on init or every time the source is modified\r\n     * @private\r\n     */\r\n    private _onInitModifySource(): void {\r\n        const source = this.getSource();\r\n        if (\r\n            !(source instanceof Function) &&\r\n            this.get('calculateZMethod') !== 'getFeatureInfo'\r\n        ) {\r\n            this._readFromImage = new ReadFromImage(\r\n                source,\r\n                this.get('calculateZMethod'),\r\n                this.get('bands'),\r\n                this.getMap()\r\n            );\r\n        } else {\r\n            this._readFromImage = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get some sample coords from the geometry while preserving the vertices.\r\n     *\r\n     * @param feature\r\n     * @param params\r\n     * @returns\r\n     * @private\r\n     */\r\n    private _sampleFeatureCoords(\r\n        feature: Feature<LineString | Point | Polygon>,\r\n        params: {\r\n            samples?: Options['samples'];\r\n            sampleSizeArea?: Options['sampleSizeArea'];\r\n        }\r\n    ): ISampledGeom {\r\n        const geom = feature.getGeometry();\r\n\r\n        let gridPolygons: Feature<Polygon>[],\r\n            contourCoords: CoordinatesXY[],\r\n            mainCoords: CoordinatesXY[]; // For polygons\r\n\r\n        const mergedParams = {\r\n            samples: params?.samples || this.getSamples(),\r\n            sampleSizeArea: params?.sampleSizeArea || this.getSampleSizeArea()\r\n        };\r\n\r\n        if (geom instanceof Point) {\r\n            mainCoords = [[geom.getCoordinates()[0], geom.getCoordinates()[1]]];\r\n        } else if (geom instanceof Polygon) {\r\n            const polygonFeature = feature as Feature<Polygon>;\r\n\r\n            const sub_coords = polygonFeature.getGeometry().getCoordinates()[0];\r\n            const contourGeom = new LineString([sub_coords[0], sub_coords[1]]);\r\n            contourCoords = getLineSamples(contourGeom, mergedParams.samples);\r\n\r\n            gridPolygons = getPolygonSamples(\r\n                polygonFeature,\r\n                this.getMap().getView().getProjection().getCode(),\r\n                mergedParams.sampleSizeArea\r\n            );\r\n            mainCoords = gridPolygons.map((g) => {\r\n                const coords = g\r\n                    .getGeometry()\r\n                    .getInteriorPoint()\r\n                    .getCoordinates();\r\n                return [coords[0], coords[1]];\r\n            });\r\n        } else if (geom instanceof LineString) {\r\n            mainCoords = getLineSamples(geom, mergedParams.samples);\r\n        }\r\n\r\n        return {\r\n            sampledCoords: {\r\n                mainCoords,\r\n                contourCoords\r\n            },\r\n            gridPolygons\r\n        };\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param coordinate\r\n     * @param tilesResolution\r\n     * @returns\r\n     * @private\r\n     */\r\n    private async _getZValuesFromImage(\r\n        coordinate: Coordinate,\r\n        tilesResolution: number\r\n    ): Promise<number> {\r\n        return await this._readFromImage.read(coordinate, tilesResolution);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param coordinate\r\n     * @param source\r\n     * @param view\r\n     * @returns\r\n     * @private\r\n     */\r\n    private async _getZValuesFromWMS(\r\n        coordinate: Coordinate,\r\n        source: TileWMS,\r\n        view: View\r\n    ): Promise<number> {\r\n        const url = source.getFeatureInfoUrl(\r\n            coordinate,\r\n            view.getResolution(),\r\n            view.getProjection(),\r\n            {\r\n                INFO_FORMAT: 'application/json',\r\n                BUFFER: 0,\r\n                FEATURE_COUNT: 1\r\n            }\r\n        );\r\n\r\n        const response = await fetch(url, {\r\n            signal: AbortSignal.timeout(this.getTimeout())\r\n        });\r\n\r\n        const data = await response.json();\r\n\r\n        return data.features[0]?.properties?.GRAY_INDEX;\r\n    }\r\n}\r\n\r\nexport enum GeneralEventTypes {\r\n    LOAD = 'load'\r\n}\r\n\r\n/**\r\n * **_[interface]_**\r\n * @private\r\n */\r\ninterface ISampledGeom {\r\n    sampledCoords: {\r\n        /**\r\n         * Sampled coordinates from LineStrings, Point coordinates,\r\n         * or sampled coordinates from Polygons, obtained by subdividing the area in multiples squares and getting each center point.\r\n         */\r\n        mainCoords: CoordinatesXY[];\r\n        /**\r\n         * Contour coordinates from Polygons features.\r\n         */\r\n        contourCoords?: CoordinatesXY[];\r\n    };\r\n    gridPolygons?: Feature<Polygon>[];\r\n}\r\n\r\n/**\r\n * **_[type]_**\r\n * @public\r\n */\r\nexport type ElevationParserEventTypes =\r\n    | 'change:samples'\r\n    | 'change:sampleSizeArea'\r\n    | 'change:source'\r\n    | 'change:calculateZMethod'\r\n    | 'change:noDataValue'\r\n    | 'change:smooth'\r\n    | 'change:bands'\r\n    | 'change:tilesResolution'\r\n    | 'change:timeout';\r\n\r\n/**\r\n * **_[interface]_**\r\n * @public\r\n */\r\nexport interface IGetElevationValues extends IElevationCoords {\r\n    /**\r\n     * Sampled Polygons\r\n     * Useful to to calculate fill and cut values on ovolume measurements\r\n     */\r\n    gridPolygons: Feature<Polygon>[];\r\n}\r\n\r\n/**\r\n * **_[type]_**\r\n * @public\r\n */\r\nexport type CoordinatesXYZ = [number, number, number];\r\n\r\n/**\r\n * **_[type]_**\r\n * @public\r\n */\r\nexport type CoordinatesXY = [number, number];\r\n\r\n/**\r\n * **_[interface]_**\r\n * @public\r\n */\r\nexport interface IElevationCoords {\r\n    /**\r\n     * Sampled coordinates from LineStrings, Point coordinates,\r\n     * or sampled coordinates from Polygons, obtained by subdividing the area in multiples squares and getting each center point.\r\n     */\r\n    mainCoords: CoordinatesXYZ[];\r\n    /**\r\n     * Contour coordinates from Polygons features.\r\n     */\r\n    contourCoords?: CoordinatesXYZ[];\r\n}\r\n\r\n/**\r\n * **_[type]_**\r\n * @public\r\n */\r\nexport type RasterSources = TileWMS | TileImage | XYZ | GeoTIFF;\r\n\r\n/**\r\n * **_[type]_**\r\n * @public\r\n */\r\nexport type CustomSourceFn = (\r\n    originalFeature: Feature<LineString | Point | Polygon>,\r\n    sampledCoords: ISampledGeom['sampledCoords']\r\n) => Promise<IElevationCoords>;\r\n\r\n/**\r\n * **_[interface]_**\r\n * @public\r\n */\r\nexport interface ElevationValuesIndividualOptions {\r\n    samples?: Options['samples'];\r\n    sampleSizeArea?: Options['sampleSizeArea'];\r\n    tilesResolution?: Options['tilesResolution'];\r\n    smooth?: Options['smooth'];\r\n}\r\n\r\n/**\r\n * **_[interface]_**\r\n * @public\r\n */\r\nexport interface Options extends Omit<ControlOptions, 'target'> {\r\n    /**\r\n     *\r\n     * Source from which it is obtained the elevation values. If not provided, the zGraph would be not displayed.\r\n     *\r\n     * If a Raster source is used and the option `resolution` is set to `max`, provide the `maxZoom` attribute\r\n     * to allow download the data in the higher resolution available.\r\n     *\r\n     * Also, you can provide a custom function to call an API or other methods to obtain the data.\r\n     *\r\n     */\r\n    source: RasterSources | CustomSourceFn;\r\n\r\n    /**\r\n     * To obtain the elevation values from the diferrents sources, you can:\r\n     * - Calculate the zValues from the rgb pixel data (`TileImage` and `XYZ` source formats need this):\r\n     *     - `Mapbox` preset: (r * 256 * 256 + g * 256 + b) * 0.1 - 10000\r\n     *     - `Terrarium` preset: (r * 256 + g + b / 256) - 32768\r\n     *     - Provided your custom function to calculate elevation from the rgb pixel data\r\n     *\r\n     * - Making requests to the geoserver (`TileWMS` source)\r\n     *      `getFeatureInfo`: make requests to the source url using service [getFeatureInfo](https://docs.geoserver.org/stable/en/user/services/wms/reference.html#getfeatureinfo)\r\n     *\r\n     * By default:\r\n     *  - `TileWMS` format use `'getFeatureInfo'` requests to the source_url to obtain the values.\r\n     *  - `TileImage` and `XYZ` formats are calculated from the pixel data using `'Mapbox'` preset.\r\n     */\r\n    calculateZMethod?:\r\n        | 'getFeatureInfo'\r\n        | 'Mapbox'\r\n        | 'Terrarium'\r\n        | ((r: number, g: number, b: number) => number);\r\n\r\n    /**\r\n     * Only used if `calculateZMethod` is not `getFeatureInfo`.\r\n     *\r\n     * This sets the resolution in wich the tiles are downloaded to calculate the z values.\r\n     *\r\n     * If `max`, the tiles will be downloaded using the maximum quality possible, but you\r\n     * have to configure the `maxZoom` attribute of the source to prevent requesting inexisting tiles.\r\n     * Using `max` provides the maximum quality, but the requests are gonna be in higher number and would be slower.\r\n     * Use the method `getMaxTilesResolution` to get the max resolution in a number number.\r\n     *\r\n     * ´current´ uses the current view resolution of the map. If the source is visible in the map,\r\n     * the already downloaded tiles would be used to the calculations so is it's the faster method.\r\n     * Use the method `getCurrentViewResolution` to get the curent view resolution number.\r\n     * Doesn't work if the source is GeoTIFF and the map use its `view`\r\n     *\r\n     * ´current´ is the default\r\n     */\r\n    tilesResolution?: number | 'max' | 'current';\r\n\r\n    /**\r\n     * Only used if `calculateZMethod` is not `getFeatureInfo`.\r\n     *\r\n     * Default is 4\r\n     */\r\n    bands?: number;\r\n\r\n    /**\r\n     * To obtain the elevation values on each distance measurement, multiples samples are taken across the line.\r\n     * This number is used as equally percentage steps across the geom, plus all the vertices positions.\r\n     * - `getFeatureInfo` on TileWMS sources will make one request per sample\r\n     * - `TileImage`and `XYZ` are calculated across each pixel after downloading the required tiles.\r\n     * The bigger the number, the greater the quality of the elevation data, but slower response times and\r\n     * bigger overhead (principally on `getFeatureInfo` method).\r\n     * This value is used to sample LinesStrings and Polygons contour\r\n     * `50` is the default\r\n     *\r\n     */\r\n    samples?: number | ((length: number) => number);\r\n\r\n    /**\r\n     * To obtain the elevation values on a volume measurement, multiples samples are taken across the polygon.\r\n     * The value provided must be in meters. The bigger the number, the greater the quality of the measurement,\r\n     * but slower response times and bigger overhead (principally on `getFeatureInfo` method).\r\n     * `'auto'` is the default\r\n     */\r\n    sampleSizeArea?: number | 'auto' | ((area: number) => number);\r\n\r\n    /**\r\n     * Smooth result values on LineStrings measurements\r\n     * `0` is the default (no smoothing)\r\n     */\r\n    smooth?: number;\r\n\r\n    /**\r\n     * When calculating the zGraph statistics from the raster dataset, you can choose to ignore specific values with the NoDataValue parameter.\r\n     * These values are considerated as transparency, so probably you want these replaced by 0.\r\n     *\r\n     * `-10000` is the default\r\n     * `false` to disable\r\n     */\r\n    noDataValue?: number | false;\r\n\r\n    /**\r\n     * Timeout in ms to wait before close the requests\r\n     *\r\n     * `5000` ms is the default\r\n     */\r\n    timeout?: number;\r\n\r\n    /**\r\n     * console.log to help debug the code\r\n     * `false` is the default\r\n     */\r\n    verbose?: boolean;\r\n}\r\n","import ElevationParser from './ol-elevation-parser';\r\nimport * as utils from './ol-elevation-parser';\r\n\r\nObject.assign(ElevationParser, utils);\r\nexport default ElevationParser;\r\n"],"names":["arr","windowSize","getter","value","setter","get","result","i","length","leftOffeset","to","count","sum","j","geojson","GeoJSON","deepObjectAssign","target","sources","forEach","source","Object","keys","key","s_val","t_val","Array","isArray","getLineSamples","geom","nSamples","totalLength","getLength","metersSample","sampledCoords","segmentCount","forEachSegment","start","end","push","segmentGeom","LineString","segmentLength","newPercentage","segmentStepPercent","coordAt","getCoordinateAt","loggerIsEnabled","logger","args","console","log","options","calculateZMethod","tilesResolution","bands","samples","smooth","sampleSizeArea","noDataValue","timeout","verbose","ReadFromImage","constructor","map","this","_projection","getProjection","getView","_view","_source","_bands","_calculateZMethod","_canvas","document","createElement","_ctx","getContext","read","coordinate","resolution","clearRect","width","height","tileGrid","_getTileGrid","tileCoord","getTileCoordForCoordAndResolution","zoom","tileSize","getTileSize","tile","getTile","tileData","getState","Promise","resolve","changeListener","removeEventListener","addEventListener","load","DataTile","getData","ImageTile","getImage","imageData","mozImageSmoothingEnabled","oImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingEnabled","HTMLImageElement","drawImage","getImageData","createImageData","data","set","origin","getOrigin","res","getResolution","w","Math","floor","h","imgData","index","pixel","_extractValuesFromPixelDEM","getMaxResolution","getMaxZoom","tilegrid","getTileGrid","XYZ","defaultTileGrid","createXYZ","TileGrid","resolutions","getResolutions","getTileGridForProjection","getForProjection","r","g","b","terrariumExtractElevation","ElevationParser","Control","bool","super","element","_countConnections","_rasterSourceIsLoaded","_initialized","_getZFromSampledCoords","async","coords","optOptions","countConnections","errorCount","coordsWithZ","countErrorsLimit","resolutionNumber","_resolution","getTilesResolution","getMap","warn","maxRes","getMaxTilesResolution","getMinResolution","coord","zValue","TileWMS","_getZValuesFromWMS","_getZValuesFromImage","undefined","baseValue","zValueRound","Number","toFixed","err","error","_options","defaultOptions","getElevationValues","feature","customOptions","waitUntilRasterSourceIsLoaded","reject","isSourceReady","retryNum","maxRetries","waitMilliseconds","setTimeout","gridPolygons","_sampleFeatureCoords","contourCoords","mainCoords","smoothValue","zCoords","zSmooth","getSmoothedCoords","assign","dispatchEvent","getSource","setSource","silent","getSamples","setSamples","getSampleSizeArea","setSampleSizeArea","getCalculateZMethod","setCalculateZMethod","getSmooth","setSmooth","getNoDataValue","setNoDataValue","setTilesResolution","getBands","setBands","getTimeout","_readFromImage","getCurrentViewResolution","setMap","_init","_addPropertyEvents","_onInitModifySource","GeneralEventTypes","LOAD","on","Function","params","getGeometry","mergedParams","Point","getCoordinates","Polygon","polygonFeature","sub_coords","contourGeom","projection","polygon","writeFeatureObject","dataProjection","featureProjection","areaPol","area","geometry","sampleMeters","polygonBbox","bbox","clippedGrid","squareGrid","units","mask","features","intersect","filter","clippedGridF","featureCollection","readFeatures","getPolygonSamples","getCode","getInteriorPoint","view","url","getFeatureInfoUrl","INFO_FORMAT","BUFFER","FEATURE_COUNT","response","fetch","signal","AbortSignal","_b","_a","json","properties","GRAY_INDEX","utils"],"mappings":";;;;;s5CAsBA,SAtBA,SAAgBA,EAAKC,EAAYC,EAAS,CAACC,GAAUA,GAAOC,GAC1D,MAAMC,EAAMH,EACNI,EAAS,GAEf,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAIQ,OAAQD,GAAK,EAAG,CACtC,MAAME,EAAcF,EAAIN,EAElBS,EAAKH,EAAIN,EAAa,EAE5B,IAAIU,EAAQ,EACRC,EAAM,EACV,IAAK,IAAIC,EALIJ,GAAe,EAAIA,EAAc,EAK3BI,EAAIH,GAAMG,EAAIb,EAAIQ,OAAQK,GAAK,EAChDD,GAAOP,EAAIL,EAAIa,IACfF,GAAS,EAGXL,EAAOC,GAAKH,EAASA,EAAOJ,EAAIO,GAAIK,EAAMD,GAASC,EAAMD,CAC1D,CAED,OAAOL,CACT,ICLA,MAAMQ,EAAU,IAAIC,EAQPC,EAAmB,CAACC,KAAWC,KACxCA,EAAQC,SAASC,IACbC,OAAOC,KAAKF,GAAQD,SAASI,IACzB,MAAMC,EAAQJ,EAAOG,GACfE,EAAQR,EAAOM,GACrBN,EAAOM,GACHE,GACAD,GACiB,iBAAVC,GACU,iBAAVD,IACNE,MAAMC,QAAQF,GACTT,EAAiBS,EAAOD,GACxBA,CAAK,GACjB,IAECP,GAGEW,EAAiB,CAC1BC,EACAC,KAEA,MAAMC,EAAcF,EAAKG,YAED,mBAAbF,IACPA,EAAWA,EAASC,IAGxB,MAEME,EAAeF,GAFE,IAAMD,EAEwB,KAE/CI,EAAiC,GACvC,IAAIC,EAAe,EAyCnB,OAtCAN,EAAKO,gBACD,CACIC,EACAC,KAGKH,GACDD,EAAcK,KAAK,CAACF,EAAM,GAAIA,EAAM,KAGxCF,IAEA,MAAMK,EAAc,IAAIC,EAAW,CAC/B,CAACJ,EAAM,GAAIA,EAAM,IACjB,CAACC,EAAI,GAAIA,EAAI,MAEXI,EAAgBF,EAAYR,YAM5BW,EAAiB,IAAMV,EAAgBS,EAG7C,IAAIE,EAAqBD,EACzB,KAAOC,EAAqB,KAAK,CAC7B,MAAMC,EAAUL,EAAYM,gBACxBF,EAAqB,KAEzBV,EAAcK,KAAKM,GACnBD,GAA0CD,CAC7C,CAEDT,EAAcK,KAAK,CAACD,EAAI,GAAIA,EAAI,IAAI,IAIrCJ,CAAa,ECjGjB,IAAIa,GAAkB,EAMf,SAAUC,KAAUC,GAC1BF,GAAiBG,QAAQC,OAAOF,EACxC,CCLA,MAAMG,EAAmB,CACrBhC,OAAQ,KACRiC,iBAAkB,iBAClBC,gBAAiB,UACjBC,MAAO,EACPC,QAAS,GACTC,OAAQ,EACRC,eAAgB,OAChBC,aAAc,IACdC,QAAS,IACTC,QAASd,GCUC,MAAOe,EASjB,WAAAC,CACI3C,EACAiC,EACAE,EACAS,GAEAC,KAAKC,YACD9C,EAAO+C,iBAAmBH,EAAII,UAAUD,gBAC5CF,KAAKI,MAAQL,EAAII,UAEjBH,KAAKK,QAAUlD,EACf6C,KAAKM,OAAShB,EAEdU,KAAKO,kBAAoBnB,EAEzBY,KAAKQ,QAAUC,SAASC,cAAc,UACtCV,KAAKW,KAAOX,KAAKQ,QAAQI,WAAW,KACvC,CAED,UAAMC,CAAKC,EAAwBC,GAE/Bf,KAAKW,KAAKK,UAAU,EAAG,EAAGhB,KAAKQ,QAAQS,MAAOjB,KAAKQ,QAAQU,QAE3D,MAAMC,EAAWnB,KAAKoB,eAEhBC,EAAYF,EAASG,kCACvBR,EACAC,GAEEQ,EAAOF,EAAU,GACjBG,EAAWL,EAASM,YAAYF,GAEhCG,EAAO1B,KAAKK,QAAQsB,QACtBN,EAAU,GACVA,EAAU,GACVA,EAAU,GACV,EACArB,KAAKC,aAqBT,IAAI2B,EAQJ,GA1BwB,IAApBF,EAAKG,kBACC,IAAIC,SAASC,IACf,MAAMC,EAAiB,KACK,IAApBN,EAAKG,YAELH,EAAKO,oBAAoB,SAAUD,GACnCD,EAAQ,OACmB,IAApBL,EAAKG,YAEZE,EAAQ,KACX,EAGLL,EAAKQ,iBAAiB,SAAUF,GAChCN,EAAKS,MAAM,IAMfT,aAAgBU,EAChBR,EAAWF,EAAKW,UACTX,aAAgBY,IACvBV,EAAWF,EAAKa,aAGfX,EAAU,OAIf,MAAMX,EAAQW,EAASX,OAASO,EAAS,IAAMA,EAGzCN,EAASU,EAASV,QAAUM,EAAS,IAAMA,EAejD,IAAIgB,EAbJxC,KAAKQ,QAAQS,MAAQA,EACrBjB,KAAKQ,QAAQU,OAASA,EAGtBlB,KAAKW,KAAK8B,0BAA2B,EAErCzC,KAAKW,KAAK+B,wBAAyB,EAEnC1C,KAAKW,KAAKgC,6BAA8B,EAExC3C,KAAKW,KAAKiC,yBAA0B,EACpC5C,KAAKW,KAAKkC,uBAAwB,EAI9BjB,aAAoBkB,kBAEpB9C,KAAKW,KAAKoC,UAAUnB,EAAU,EAAG,GAEjCY,EAAYxC,KAAKW,KAAKqC,aAAa,EAAG,EAAG/B,EAAOC,KAGhDsB,EAAYxC,KAAKW,KAAKsC,gBAAgBhC,EAAOC,GAE7CsB,EAAUU,KAAKC,IAAIvB,IAGvB,MAAMwB,EAASjC,EAASkC,UAAU9B,GAC5B+B,EAAMnC,EAASoC,cAAchC,GAE7BiC,EAAIC,KAAKC,OAAQ5C,EAAW,GAAKsC,EAAO,IAAME,EAAOrC,GACrD0C,EAAIF,KAAKC,OAAQN,EAAO,GAAKtC,EAAW,IAAMwC,EAAOpC,GAErD0C,EAAUpB,EAAUU,KACpBW,GAASL,EAAIG,EAAI1C,GAASjB,KAAKM,OAE/BwD,EAAQ,CACVF,EAAQC,EAAQ,GAChBD,EAAQC,EAAQ,GAChBD,EAAQC,EAAQ,GAChBD,EAAQC,EAAQ,IAGpB,OAAO7D,KAAK+D,2BAA2BD,EAC1C,CAMD,gBAAAE,GACI,MAAMzC,EAAOvB,KAAKoB,eAAe6C,aACjC,OAAI1C,EAAavB,KAAKoB,eAAemC,cAAchC,GAC5C,IACV,CAMO,YAAAH,GACJ,IAAI8C,EAAWlE,KAAKK,QAAQ8D,cAE5B,IAAKD,EACD,GAAIlE,KAAKK,mBAAmB+D,EAAK,CAC7B,MAAMC,EAAkBC,EAAAA,YACxBJ,EAAW,IAAIK,EAAS,CACpBnB,OAAQiB,EAAgBhB,UAAU,GAClCmB,YAAaH,EAAgBI,kBAEpC,MACGP,EAAWQ,EAAwBC,iBAAC3E,KAAKC,aAIjD,OAAOiE,CACV,CAMO,0BAAAH,CAA2BD,GAC/B,OACI9D,KAAKO,mBAC6B,mBAA3BP,KAAKO,kBAELP,KAAKO,kBAAkBuD,EAAM,GAAIA,EAAM,GAAIA,EAAM,IACtB,WAA3B9D,KAAKO,mBApLQqE,EAqLUd,EAAM,GArLLe,EAqLSf,EAAM,GArLJgB,EAqLQhB,EAAM,GApLzB,IAA3B,IAAJc,EAAU,IAAU,IAAJC,EAAUC,GAAW,KAqLH,cAA3B9E,KAAKO,kBAlLU,EAACqE,EAAWC,EAAWC,IAC1C,IAAJF,EAAUC,EAAIC,EAAI,IAAM,MAkLhBC,CAA0BjB,EAAM,GAAIA,EAAM,GAAIA,EAAM,SADxD,EAtLgB,IAACc,EAAWC,EAAWC,CAyLjD,EChKgB,MAAAE,UAAwBC,EAoDzC,WAAAnF,CAAYX,GH1Fe,IAAC+F,EG2FxBC,MAAM,CACFC,QAAS3E,SAASC,cAAc,SApD9BV,KAAiBqF,kBAAG,EAEpBrF,KAAqBsF,uBAAG,EAExBtF,KAAYuF,cAAG,EAyWjBvF,KAAsBwF,uBAAGC,MAC7BC,EACAC,EAA+C,QAI/C3F,KAAKqF,oBACL,MAAMO,EAAmB5F,KAAKqF,kBAC9B,IAAIQ,EAAa,EAEjB,MAAMC,EAAc,GAEd3I,EAAS6C,KAAK5D,IAAI,UAKlB2J,EAAmBL,EAAOnJ,QAAU,EAAI,EAAI,EAElD,IAAIyJ,EAEJ,MAAMC,GACFN,aAAU,EAAVA,EAAYtG,kBAAmBW,KAAKkG,qBAExC,GAAoB,YAAhBD,EACAD,EAAmBhG,KAAKmG,SAAShG,UAAUoD,gBAEtCyC,GACD/G,QAAQmH,KAAK,iDAEd,GAAoB,QAAhBH,EAAuB,CAC9B,MAAMI,EAASrG,KAAKsG,wBAChBD,EAAQL,EAAmBK,EAC1BpH,QAAQmH,KAAK,2CACrB,MAEGJ,EAAmBC,EAGlBD,IACDA,EACIhG,KAAKmG,SAAShG,UAAUoG,oBArCG,IAuC/BtH,QAAQmH,KAAK,6BAA8BJ,IAG/C,IAAK,MAAMQ,KAASd,EAChB,IAEI,GAAI1F,KAAKqF,oBAAsBO,EAE3B,OADA7G,EAAO,oDACA,KAGX,IAAI0H,EAMAA,EAHAtJ,aAAkBuJ,GACe,mBAAjC1G,KAAK5D,IAAI,0BAEM4D,KAAK2G,mBAChBH,EACArJ,EACA6C,KAAKmG,SAAShG,iBAGHH,KAAK4G,qBAChBJ,EACAR,IAIwB,IAA5BhG,KAAK5D,IAAI,iBACTqK,EACIA,IAAWzG,KAAK5D,IAAI,oBAAiByK,EAAYJ,GAGzD,MAAMK,EAC+B,cAAjC9G,KAAK5D,IAAI,qBACF,WACDyK,EAEJE,OACgB,IAAXN,GAA0BA,IAAWK,EACtCE,OAAOP,EAAOQ,QAAQ,SACtBJ,EAEVf,EAAYxH,KAAK,IAAIkI,EAAOO,GAC/B,CAAC,MAAOG,GAGL,GAFArB,IACA5G,QAAQkI,MAAMD,GACVrB,GAAcE,EACd,MAAMmB,CAEb,CAGL,OAAOpB,CAAW,EAvZlB9F,KAAKoH,SAAWrK,EAAiB,CAAE,EAAEsK,EAAgBlI,GAI/Ca,KAAKoH,SAASjK,kBAAkBuJ,GACC,mBAAnC1G,KAAKoH,SAAShI,mBAEdY,KAAKoH,SAAShI,iBAAmB,UHtGb8F,EGyGRlF,KAAKoH,SAASxH,QHxGlCd,EAAkBoG,CGyGjB,CAWD,wBAAMoC,CACFC,EACAC,EAAkD,MAElD,IACI,MAAMC,EAAgC,IAClC,IAAI3F,SAAQ,CAACC,EAAS2F,KAClB,MAAMC,EAAgB,CAClBC,EAAW,EACXC,EAAa,EACbC,EAAmB,OAE0B,UAAxC3K,EAAyB0E,aAC1B+F,EAEeC,EACXH,IAEAK,YACI,IAAMJ,EAAcC,MACpBE,GAIR/F,EAAQ,KACX,EAGL4F,GAAe,KAGjB1J,cAAEA,EAAa+J,aAAEA,GAAiBhI,KAAKiI,qBACzCV,EACAC,GAGJ,IAAIU,EAAiCC,EAErC,MAAMhL,EAAS6C,KAAK5D,IAAI,UA4BxB,GA1BsB,mBAAXe,IAEJgL,aAAYD,uBAAwB/K,EACnCoK,EACAtJ,KAGC+B,KAAKsF,8BACAmC,IACNzH,KAAKsF,uBAAwB,GAGjC6C,QAAmBnI,KAAKwF,uBACpBvH,EAAckK,WACdX,GAIAW,GAAclK,EAAciK,gBAC5BA,QAAsBlI,KAAKwF,uBACvBvH,EAAciK,cACdV,KAKO,OAAfW,EACA,OAAO,KAGX,MAAM3I,GAASgI,aAAA,EAAAA,EAAehI,SAAUQ,KAAK5D,IAAI,UAMjD,OAJIoD,IACA2I,EJ/BiB,EAC7BrC,EACAsC,EAAc,KAGd,MAAMC,GADNvC,EAAc,IAAIA,IACU/F,KAAKyG,GAAUA,EAAM,KAE3C8B,EAAU9I,EAAO6I,EAASD,GAEhC,OAAOtC,EAAY/F,KAAI,CAACyG,EAAOlK,KAC3BkK,EAAM,GAAK8B,EAAQhM,GACZkK,IACT,EImBuB+B,CAAkBJ,EAAY3I,IAG/CpC,OAAAoL,OAAApL,OAAAoL,OAAA,CACIL,cACID,GAAiB,CACjBA,kBAEAF,GAAgB,CAChBA,gBAGX,CAAC,MAAOd,GAEL,OADAlH,KAAKyI,cAAc,SACZvB,CACV,CACJ,CAMD,SAAAwB,GACI,OAAO1I,KAAK5D,IAAI,SACnB,CAMD,SAAAuM,CAAUxL,EAA2ByL,GAAS,GAC1C5I,KAAKmD,IAAI,SAAUhG,EAAQyL,EAC9B,CAMD,UAAAC,GACI,OAAO7I,KAAK5D,IAAI,UACnB,CAMD,UAAA0M,CAAWvJ,EAA6BqJ,GAAS,GAC7C5I,KAAKmD,IAAI,UAAW5D,EAASqJ,EAChC,CAMD,iBAAAG,GACI,OAAO/I,KAAK5D,IAAI,iBACnB,CAMD,iBAAA4M,CACIvJ,EACAmJ,GAEA5I,KAAKmD,IAAI,iBAAkB1D,EAAgBmJ,EAC9C,CAMD,mBAAAK,GACI,OAAOjJ,KAAK5D,IAAI,mBACnB,CAMD,mBAAA8M,CACI9J,EACAwJ,GAAS,GAET5I,KAAKmD,IAAI,mBAAoB/D,EAAkBwJ,EAClD,CAMD,SAAAO,GACI,OAAOnJ,KAAK5D,IAAI,SACnB,CAMD,SAAAgN,CAAU5J,EAA2BoJ,GAAS,GAC1C5I,KAAKmD,IAAI,SAAU3D,EAAQoJ,EAC9B,CAMD,cAAAS,GACI,OAAOrJ,KAAK5D,IAAI,cACnB,CAMD,cAAAkN,CAAe5J,EAAqCkJ,GAAS,GACzD5I,KAAKmD,IAAI,cAAezD,EAAakJ,EACxC,CAMD,kBAAA1C,GACI,OAAOlG,KAAK5D,IAAI,kBACnB,CAMD,kBAAAmN,CACIlK,EACAuJ,GAAS,GAET5I,KAAKmD,IAAI,kBAAmB9D,EAAiBuJ,EAChD,CAMD,QAAAY,GACI,OAAOxJ,KAAK5D,IAAI,QACnB,CAMD,QAAAqN,CAASnK,EAAyBsJ,GAAS,GACvC5I,KAAKmD,IAAI,QAAS7D,EAAOsJ,EAC5B,CAMD,UAAAc,GACI,OAAO1J,KAAK5D,IAAI,UACnB,CAMD,UAAA2L,CAAWpI,EAA6BiJ,GAAS,GAC7C5I,KAAKmD,IAAI,UAAWxD,EAASiJ,EAChC,CASD,qBAAAtC,GACI,OAAItG,KAAK2J,eAAuB3J,KAAK2J,eAAe3F,mBAC7C,IACV,CASD,wBAAA4F,GACI,OAAO5J,KAAKmG,SAAShG,UAAUoD,eAClC,CAOD,MAAAsG,CAAO9J,GACHoF,MAAM0E,OAAO9J,GAETA,IAEKC,KAAKuF,cAAcvF,KAAK8J,QAEpC,CAiHO,KAAAA,GACJ9J,KAAK8I,WAAW9I,KAAKoH,SAAS7H,SAAwB,GAEtDS,KAAKgJ,kBACDhJ,KAAKoH,SAAS3H,gBACC,GAGnBO,KAAKkJ,oBACDlJ,KAAKoH,SAAShI,kBACC,GAGnBY,KAAKsJ,eAAetJ,KAAKoH,SAAS1H,aAA4B,GAE9DM,KAAKoJ,UAAUpJ,KAAKoH,SAAS5H,QAAuB,GAEpDQ,KAAKuJ,mBACDvJ,KAAKoH,SAAS/H,iBACC,GAGnBW,KAAKyJ,SAASzJ,KAAKoH,SAAS9H,OAAsB,GAElDU,KAAK+H,WAAW/H,KAAKoH,SAASzH,SAAwB,GAGtDK,KAAK2I,UAAU3I,KAAKoH,SAASjK,QAAuB,GAEpD6C,KAAK+J,qBAEL/J,KAAKgK,sBAELhK,KAAKuF,cAAe,EAEpBvF,KAAKyI,cAAcwB,EAAkBC,KACxC,CAKO,kBAAAH,GACJ/J,KAAKmK,GACD,CAAC,gBAAiB,eAAgB,4BAClC,KACInK,KAAKgK,qBAAqB,GAGrC,CAMO,mBAAAA,GACJ,MAAM7M,EAAS6C,KAAK0I,YAEdvL,aAAkBiN,UACa,mBAAjCpK,KAAK5D,IAAI,oBAST4D,KAAK2J,eAAiB,KAPtB3J,KAAK2J,eAAiB,IAAI9J,EACtB1C,EACA6C,KAAK5D,IAAI,oBACT4D,KAAK5D,IAAI,SACT4D,KAAKmG,SAKhB,CAUO,oBAAA8B,CACJV,EACA8C,GAKA,MAAMzM,EAAO2J,EAAQ+C,cAErB,IAAItC,EACAE,EACAC,EAEJ,MAAMoC,EAAe,CACjBhL,SAAS8K,aAAM,EAANA,EAAQ9K,UAAWS,KAAK6I,aACjCpJ,gBAAgB4K,aAAM,EAANA,EAAQ5K,iBAAkBO,KAAK+I,qBAGnD,GAAInL,aAAgB4M,EAChBrC,EAAa,CAAC,CAACvK,EAAK6M,iBAAiB,GAAI7M,EAAK6M,iBAAiB,UAC5D,GAAI7M,aAAgB8M,EAAS,CAChC,MAAMC,EAAiBpD,EAEjBqD,EAAaD,EAAeL,cAAcG,iBAAiB,GAC3DI,EAAc,IAAIrM,EAAW,CAACoM,EAAW,GAAIA,EAAW,KAC9D1C,EAAgBvK,EAAekN,EAAaN,EAAahL,SAEzDyI,EJhgBqB,EAC7B2C,EACAG,EACAjN,KAEA,MAAMkN,EAAUlO,EAAQmO,mBAAmBL,EAAgB,CACvDM,eAAgB,YAChBC,kBAAmBJ,IAGjBK,EAAUC,EAAKL,EAAQM,UAE7B,IAAIC,EAEa,SAAbzN,EACwB,iBAAbA,EACPyN,EAAezN,EACY,mBAAbA,IACdyN,EAAezN,EAASsN,IAGPG,EAAjBH,GAAW,IAAqB,GAC3BA,EAAU,IAAsB,EAChCA,EAAU,IAAuB,GACjCA,EAAU,IAAwB,GACvB,IAGxB,MAAMI,EAAcC,EAAKT,GAOzB,IAAIU,EALSC,EAAWH,EAAaD,EAAe,IAAM,CACtDK,MAAO,aACPC,KAAMb,EAAQM,WAGKQ,SAAS9L,KAAKwH,GACjCuE,EAAUvE,EAAQ8D,SAAUN,KAIhCU,EAAcA,EAAYM,QAAQxE,GAAYA,IAE9C,MAAMyE,EAAeC,oBAAkBR,GAEvC,OAAO5O,EAAQqP,aAAaF,EAAc,CACtCf,eAAgB,YAChBC,kBAAmBJ,GACC,EIidDqB,CACXxB,EACA3K,KAAKmG,SAAShG,UAAUD,gBAAgBkM,UACxC7B,EAAa9K,gBAEjB0I,EAAaH,EAAajI,KAAK8E,IAC3B,MAAMa,EAASb,EACVyF,cACA+B,mBACA5B,iBACL,MAAO,CAAC/E,EAAO,GAAIA,EAAO,GAAG,GAEpC,MAAU9H,aAAgBY,IACvB2J,EAAaxK,EAAeC,EAAM2M,EAAahL,UAGnD,MAAO,CACHtB,cAAe,CACXkK,aACAD,iBAEJF,eAEP,CASO,0BAAMpB,CACV9F,EACAzB,GAEA,aAAaW,KAAK2J,eAAe9I,KAAKC,EAAYzB,EACrD,CAUO,wBAAMsH,CACV7F,EACA3D,EACAmP,WAEA,MAAMC,EAAMpP,EAAOqP,kBACf1L,EACAwL,EAAK/I,gBACL+I,EAAKpM,gBACL,CACIuM,YAAa,mBACbC,OAAQ,EACRC,cAAe,IAIjBC,QAAiBC,MAAMN,EAAK,CAC9BO,OAAQC,YAAYpN,QAAQK,KAAK0J,gBAKrC,OAAqC,QAA9BsD,EAAkB,QAAlBC,SAFYL,EAASM,QAEhBrB,SAAS,UAAI,IAAAoB,OAAA,EAAAA,EAAAE,kBAAY,IAAAH,OAAA,EAAAA,EAAAI,UACxC,EAGL,IAAYnD,GAAZ,SAAYA,GACRA,EAAA,KAAA,MACH,CAFD,CAAYA,IAAAA,EAEX,CAAA,6FCjrBD7M,OAAOoL,OAAOxD,EAAiBqI","x_google_ignoreList":[0]}